"""
SOC Agent Reporter - Incident Report Generation

This module generates comprehensive incident reports from investigation
results, providing both human-readable and machine-processable formats.
"""

import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path
from dataclasses import dataclass
import markdown
from jinja2 import Template


@dataclass
class ReportSection:
    """Structured section of an investigation report"""
    title: str
    content: str
    severity: str = "info"  # info, warning, error, critical
    data: Optional[Dict[str, Any]] = None


class IncidentReporter:
    """
    Incident Report Generator for SOC Agent
    
    Creates comprehensive, structured reports from investigation contexts
    with support for multiple output formats (JSON, Markdown, HTML).
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Report configuration
        self.reports_dir = Path(config.get('reports_dir', 'reports'))
        self.reports_dir.mkdir(parents=True, exist_ok=True)
        
        self.templates_dir = Path(config.get('templates_dir', 'templates'))
        self.include_raw_data = config.get('include_raw_data', False)
        self.auto_save = config.get('auto_save', True)
        
        # Initialize templates
        self._init_templates()
        
        self.logger.info(f"Incident reporter initialized - reports: {self.reports_dir}")
    
    def _init_templates(self):
        """Initialize report templates"""
        self.markdown_template = Template("""
# Security Incident Investigation Report

**Event ID:** {{ event_id }}  
**Investigation Date:** {{ timestamp }}  
**Duration:** {{ duration_minutes }} minutes  
**Risk Level:** {{ risk_level | upper }}  

## Executive Summary

{{ executive_summary }}

## Event Details

**Event Type:** {{ event_type }}  
**Source IP:** {{ source_ip }}  
**Detection Time:** {{ detection_time }}  

{{ event_details }}

## Threat Intelligence Analysis

{{ threat_intelligence_summary }}

### Intelligence Sources
{% for source in intelligence_sources -%}
- **{{ source.name }}**: {{ source.summary }}
{% endfor %}

## Risk Assessment

**Overall Risk Score:** {{ risk_score }}/1.0 ({{ risk_level | upper }})

| Component | Score | Weight | Contribution |
|-----------|-------|--------|--------------|
| Base Risk | {{ base_risk }} | 30% | {{ (base_risk * 0.3) | round(3) }} |
| Intelligence Risk | {{ intel_risk }} | 50% | {{ (intel_risk * 0.5) | round(3) }} |
| Pattern Risk | {{ pattern_risk }} | 20% | {{ (pattern_risk * 0.2) | round(3) }} |

**Confidence Level:** {{ confidence }}%

{{ risk_explanation }}

## Recommended Actions

{% for action in recommended_actions -%}
### {{ loop.index }}. {{ action.action_type }} (Priority {{ action.priority }})

**Description:** {{ action.description }}  
**Estimated Effort:** {{ action.estimated_effort }}  
{% if action.technical_details -%}
**Technical Details:** {{ action.technical_details }}  
{% endif %}

{% endfor %}

## Investigation Timeline

{% for step in reasoning_log -%}
- {{ step }}
{% endfor %}

## Technical Details

{% if pattern_insights -%}
### Pattern Analysis
{% for insight in pattern_insights -%}
- **{{ insight.pattern_type }}**: {{ insight.description }} (Confidence: {{ (insight.confidence * 100) | round(1) }}%)
{% endfor %}
{% endif %}

### Indicators of Compromise (IoCs)

{% if iocs -%}
{% for ioc in iocs -%}
- **{{ ioc.type }}**: `{{ ioc.value }}` (Source: {{ ioc.source }})
{% endfor %}
{% else -%}
No specific indicators of compromise identified.
{% endif %}

## Appendix

{% if include_raw_data -%}
### Raw Intelligence Data
```json
{{ raw_data | tojson(indent=2) }}
```
{% endif %}

---
*Report generated by AITIA SOC Agent v2.0*  
*Classification: {{ classification }}*
""")
    
    async def generate_report(self, context) -> Dict[str, Any]:
        """
        Generate comprehensive investigation report
        
        Args:
            context: InvestigationContext from the planner
            
        Returns:
            Complete report data structure
        """
        try:
            # Extract core data
            event_data = context.event_data
            risk_assessment = context.risk_assessment or {}
            intelligence_data = context.intelligence_data or {}
            
            # Calculate derived metrics
            duration_minutes = round(
                (datetime.utcnow() - context.start_time).total_seconds() / 60, 2
            )
            
            # Generate report sections
            report = {
                'metadata': self._generate_metadata(context, duration_minutes),
                'executive_summary': self._generate_executive_summary(context),
                'event_analysis': self._generate_event_analysis(context),
                'threat_intelligence': self._generate_threat_intelligence_section(context),
                'risk_assessment': self._generate_risk_assessment_section(context),
                'recommended_actions': self._generate_actions_section(context),
                'investigation_timeline': context.reasoning_log,
                'technical_details': self._generate_technical_section(context),
                'indicators': self._extract_indicators(context),
                'raw_data': intelligence_data if self.include_raw_data else {}
            }
            
            # Generate formatted outputs
            report['formats'] = {}
            report['formats']['markdown'] = self._generate_markdown_report(report, context)
            report['formats']['json'] = json.dumps(report, indent=2, default=str)
            
            # Auto-save if configured
            if self.auto_save:
                await self._save_report(context.event_id, report)
            
            self.logger.info(f"Generated report for {context.event_id}")
            return report
            
        except Exception as e:
            self.logger.error(f"Failed to generate report: {e}")
            return self._generate_error_report(context, e)
    
    def _generate_metadata(self, context, duration_minutes: float) -> Dict[str, Any]:
        """Generate report metadata"""
        return {
            'event_id': context.event_id,
            'report_version': '2.0',
            'generated_at': datetime.utcnow().isoformat(),
            'investigation_duration_minutes': duration_minutes,
            'agent_version': '2.0.0',
            'classification': 'INTERNAL',
            'status': 'COMPLETED'
        }
    
    def _generate_executive_summary(self, context) -> str:
        """Generate executive summary based on investigation results"""
        event_type = context.event_data.get('event_type', 'unknown')
        risk_level = context.risk_assessment.get('risk_level', 'unknown')
        risk_score = context.risk_assessment.get('risk_score', 0.0)
        
        # Risk level descriptions
        risk_descriptions = {
            'low': 'appears to be benign or poses minimal threat',
            'medium': 'requires monitoring and investigation',
            'high': 'poses significant security risk and requires immediate attention',
            'critical': 'represents imminent threat requiring emergency response'
        }
        
        source_ip = context.event_data.get('source_ip', 'unknown')
        intel_sources = len(context.intelligence_data.get('sources', []))
        
        summary = f"""
This investigation analyzed a {event_type} security event involving source IP {source_ip}. 
After gathering intelligence from {intel_sources} external sources and performing risk analysis, 
the event has been classified as **{risk_level.upper()}** risk (score: {risk_score:.2f}/1.0).

The investigation determined that this event {risk_descriptions.get(risk_level, 'requires further analysis')}.
        """.strip()
        
        # Add specific context based on findings
        if context.intelligence_data.get('reputation_score', 0) > 0.7:
            summary += "\n\n⚠️  **High-confidence threat intelligence indicates malicious activity.**"
        
        if len(context.recommended_actions or []) > 0:
            action_count = len(context.recommended_actions)
            summary += f"\n\n📋 **{action_count} prioritized response actions have been recommended.**"
        
        return summary
    
    def _generate_event_analysis(self, context) -> Dict[str, Any]:
        """Generate detailed event analysis section"""
        event_data = context.event_data
        
        analysis = {
            'event_type': event_data.get('event_type', 'unknown'),
            'source_ip': event_data.get('source_ip'),
            'detection_time': event_data.get('timestamp', context.start_time.isoformat()),
            'user_agent': event_data.get('user_agent'),
            'payload_summary': self._summarize_payload(event_data.get('payload', {})),
            'event_characteristics': self._analyze_event_characteristics(event_data)
        }
        
        return analysis
    
    def _generate_threat_intelligence_section(self, context) -> Dict[str, Any]:
        """Generate threat intelligence analysis section"""
        intel_data = context.intelligence_data
        
        section = {
            'sources_consulted': intel_data.get('sources', []),
            'overall_reputation_score': intel_data.get('reputation_score', 0.0),
            'confidence': intel_data.get('confidence', 0.0),
            'threat_indicators': intel_data.get('threat_indicators', []),
            'source_details': []
        }
        
        # Process individual source results
        individual_results = intel_data.get('individual_results', [])
        for result in individual_results:
            if result.get('reputation_score', 0) > 0:
                section['source_details'].append({
                    'source': result.get('source', 'unknown'),
                    'reputation_score': result.get('reputation_score', 0),
                    'indicators': result.get('indicators', []),
                    'summary': self._summarize_source_result(result)
                })
        
        return section
    
    def _generate_risk_assessment_section(self, context) -> Dict[str, Any]:
        """Generate detailed risk assessment section"""
        risk_data = context.risk_assessment or {}
        
        section = {
            'overall_score': risk_data.get('risk_score', 0.0),
            'risk_level': risk_data.get('risk_level', 'unknown'),
            'confidence': risk_data.get('confidence', 0.0),
            'component_scores': {
                'base_risk': risk_data.get('base_risk', 0.0),
                'intelligence_risk': risk_data.get('intel_risk', 0.0),
                'pattern_risk': risk_data.get('pattern_risk', 0.0)
            },
            'risk_factors': self._identify_risk_factors(context),
            'mitigating_factors': self._identify_mitigating_factors(context)
        }
        
        return section
    
    def _generate_actions_section(self, context) -> List[Dict[str, Any]]:
        """Generate recommended actions section"""
        actions = context.recommended_actions or []
        
        formatted_actions = []
        for action in actions:
            formatted_actions.append({
                'action_type': action.get('action_type', 'UNKNOWN'),
                'priority': action.get('priority', 5),
                'description': action.get('description', ''),
                'estimated_effort': action.get('estimated_effort', 'Unknown'),
                'technical_details': action.get('technical_details', ''),
                'urgency': self._determine_action_urgency(action)
            })
        
        return formatted_actions
    
    def _generate_technical_section(self, context) -> Dict[str, Any]:
        """Generate technical details section"""
        section = {
            'investigation_phases': [phase.value for phase in context.__dict__.get('phases_completed', [])],
            'tools_used': context.intelligence_data.get('sources_queried', []),
            'pattern_insights': [],
            'network_analysis': self._analyze_network_indicators(context),
            'behavioral_analysis': self._analyze_behavioral_indicators(context)
        }
        
        return section
    
    def _extract_indicators(self, context) -> List[Dict[str, Any]]:
        """Extract indicators of compromise from investigation"""
        indicators = []
        
        # IP indicators
        if source_ip := context.event_data.get('source_ip'):
            reputation = context.intelligence_data.get('reputation_score', 0)
            indicators.append({
                'type': 'ip',
                'value': source_ip,
                'confidence': reputation,
                'source': 'investigation',
                'description': f"Source IP with reputation score {reputation:.2f}"
            })
        
        # URL indicators
        if url := context.event_data.get('url'):
            indicators.append({
                'type': 'url',
                'value': url,
                'confidence': 0.5,
                'source': 'investigation',
                'description': 'Suspicious URL from event data'
            })
        
        # Extract from threat intelligence
        for indicator_text in context.intelligence_data.get('threat_indicators', []):
            indicators.append({
                'type': 'intelligence',
                'value': indicator_text,
                'confidence': 0.7,
                'source': 'threat_intelligence',
                'description': 'Threat intelligence indicator'
            })
        
        return indicators
    
    def _generate_markdown_report(self, report_data: Dict[str, Any], context) -> str:
        """Generate markdown formatted report"""
        template_vars = {
            'event_id': context.event_id,
            'timestamp': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC'),
            'duration_minutes': report_data['metadata']['investigation_duration_minutes'],
            'risk_level': context.risk_assessment.get('risk_level', 'unknown'),
            'risk_score': context.risk_assessment.get('risk_score', 0.0),
            'executive_summary': report_data['executive_summary'],
            'event_type': context.event_data.get('event_type', 'unknown'),
            'source_ip': context.event_data.get('source_ip', 'N/A'),
            'detection_time': context.event_data.get('timestamp', 'N/A'),
            'event_details': self._format_event_details(context.event_data),
            'threat_intelligence_summary': self._format_threat_intelligence_summary(context.intelligence_data),
            'intelligence_sources': self._format_intelligence_sources(report_data['threat_intelligence']),
            'base_risk': context.risk_assessment.get('base_risk', 0.0),
            'intel_risk': context.risk_assessment.get('intel_risk', 0.0),
            'pattern_risk': context.risk_assessment.get('pattern_risk', 0.0),
            'confidence': round(context.risk_assessment.get('confidence', 0.0) * 100, 1),
            'risk_explanation': self._generate_risk_explanation(context),
            'recommended_actions': report_data['recommended_actions'],
            'reasoning_log': context.reasoning_log,
            'pattern_insights': [],
            'iocs': report_data['indicators'],
            'include_raw_data': self.include_raw_data,
            'raw_data': report_data['raw_data'],
            'classification': report_data['metadata']['classification']
        }
        
        return self.markdown_template.render(**template_vars)
    
    def _summarize_payload(self, payload: Any) -> str:
        """Summarize payload content for report"""
        if not payload:
            return "No payload data available"
        
        if isinstance(payload, dict):
            key_count = len(payload.keys())
            return f"Structured data with {key_count} fields"
        elif isinstance(payload, str):
            return f"Text data ({len(payload)} characters)"
        else:
            return f"Data of type {type(payload).__name__}"
    
    def _analyze_event_characteristics(self, event_data: Dict[str, Any]) -> List[str]:
        """Analyze and list event characteristics"""
        characteristics = []
        
        if event_data.get('source_ip'):
            characteristics.append(f"Source IP: {event_data['source_ip']}")
        
        if event_data.get('user_agent'):
            characteristics.append("User agent present")
        
        if event_data.get('payload'):
            characteristics.append("Payload data included")
        
        if event_data.get('internal_source'):
            characteristics.append("Internal network source")
        
        return characteristics
    
    def _summarize_source_result(self, result: Dict[str, Any]) -> str:
        """Summarize individual source result"""
        reputation = result.get('reputation_score', 0)
        indicators = result.get('indicators', [])
        
        if reputation > 0.7:
            return f"High threat confidence ({reputation:.2f})"
        elif reputation > 0.3:
            return f"Medium threat confidence ({reputation:.2f})"
        elif indicators:
            return f"Some indicators present ({len(indicators)} found)"
        else:
            return "No significant threats detected"
    
    def _identify_risk_factors(self, context) -> List[str]:
        """Identify factors contributing to risk"""
        factors = []
        
        risk_score = context.risk_assessment.get('risk_score', 0)
        intel_score = context.intelligence_data.get('reputation_score', 0)
        
        if intel_score > 0.5:
            factors.append("External threat intelligence indicates malicious activity")
        
        if context.event_data.get('payload', {}).get('failed_login_attempts', 0) > 5:
            factors.append("Multiple failed authentication attempts detected")
        
        if context.event_data.get('internal_source'):
            factors.append("Activity originated from internal network")
        
        event_type = context.event_data.get('event_type')
        if event_type in ['malware_detection', 'ddos_signs']:
            factors.append(f"Event type ({event_type}) inherently high risk")
        
        return factors
    
    def _identify_mitigating_factors(self, context) -> List[str]:
        """Identify factors that reduce risk"""
        factors = []
        
        intel_confidence = context.intelligence_data.get('confidence', 0)
        if intel_confidence < 0.5:
            factors.append("Low confidence in threat intelligence data")
        
        if not context.intelligence_data.get('threat_indicators'):
            factors.append("No specific threat indicators identified")
        
        sources_count = len(context.intelligence_data.get('sources', []))
        if sources_count < 2:
            factors.append("Limited threat intelligence sources consulted")
        
        return factors
    
    def _determine_action_urgency(self, action: Dict[str, Any]) -> str:
        """Determine urgency level for an action"""
        priority = action.get('priority', 5)
        action_type = action.get('action_type', '')
        
        if priority <= 1 or action_type == 'ESCALATE':
            return 'IMMEDIATE'
        elif priority <= 2:
            return 'HIGH'
        elif priority <= 3:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _analyze_network_indicators(self, context) -> Dict[str, Any]:
        """Analyze network-related indicators"""
        analysis = {
            'source_ip_analysis': {},
            'geographic_indicators': {},
            'network_behavior': []
        }
        
        if source_ip := context.event_data.get('source_ip'):
            analysis['source_ip_analysis'] = {
                'ip': source_ip,
                'reputation_score': context.intelligence_data.get('reputation_score', 0),
                'is_internal': context.event_data.get('internal_source', False)
            }
        
        return analysis
    
    def _analyze_behavioral_indicators(self, context) -> Dict[str, Any]:
        """Analyze behavioral indicators"""
        analysis = {
            'user_agent_analysis': {},
            'timing_analysis': {},
            'payload_analysis': {}
        }
        
        if user_agent := context.event_data.get('user_agent'):
            analysis['user_agent_analysis'] = {
                'present': True,
                'value': user_agent,
                'suspicious_patterns': self._check_suspicious_user_agent(user_agent)
            }
        
        return analysis
    
    def _check_suspicious_user_agent(self, user_agent: str) -> List[str]:
        """Check for suspicious patterns in user agent"""
        patterns = []
        ua_lower = user_agent.lower()
        
        suspicious_keywords = ['bot', 'crawler', 'scanner', 'curl', 'wget', 'python']
        for keyword in suspicious_keywords:
            if keyword in ua_lower:
                patterns.append(f"Contains '{keyword}' keyword")
        
        return patterns
    
    def _format_event_details(self, event_data: Dict[str, Any]) -> str:
        """Format event details for markdown"""
        details = []
        
        for key, value in event_data.items():
            if key not in ['event_type', 'source_ip', 'timestamp']:
                details.append(f"**{key.replace('_', ' ').title()}:** {value}")
        
        return '\n'.join(details) if details else "No additional event details available."
    
    def _format_threat_intelligence_summary(self, intel_data: Dict[str, Any]) -> str:
        """Format threat intelligence summary"""
        if not intel_data or not intel_data.get('sources'):
            return "No threat intelligence data available."
        
        sources_count = len(intel_data.get('sources', []))
        reputation = intel_data.get('reputation_score', 0)
        confidence = intel_data.get('confidence', 0)
        
        summary = f"Consulted {sources_count} threat intelligence sources with "
        summary += f"maximum reputation score of {reputation:.2f} "
        summary += f"and overall confidence of {confidence:.1%}."
        
        return summary
    
    def _format_intelligence_sources(self, threat_intel_section: Dict[str, Any]) -> List[Dict[str, str]]:
        """Format intelligence sources for template"""
        formatted_sources = []
        
        for detail in threat_intel_section.get('source_details', []):
            formatted_sources.append({
                'name': detail['source'].title(),
                'summary': detail['summary']
            })
        
        return formatted_sources
    
    def _generate_risk_explanation(self, context) -> str:
        """Generate human-readable risk explanation"""
        risk_level = context.risk_assessment.get('risk_level', 'unknown')
        risk_score = context.risk_assessment.get('risk_score', 0)
        
        explanations = {
            'low': "The event shows minimal indicators of malicious activity and poses low risk to the organization.",
            'medium': "The event contains some suspicious characteristics that warrant monitoring and investigation.",
            'high': "The event demonstrates significant threat indicators and requires immediate attention and response.",
            'critical': "The event represents an imminent security threat requiring emergency response procedures."
        }
        
        base_explanation = explanations.get(risk_level, "Risk level assessment is inconclusive.")
        
        # Add specific factors
        intel_score = context.intelligence_data.get('reputation_score', 0)
        if intel_score > 0.7:
            base_explanation += " External threat intelligence confirms malicious activity."
        
        return base_explanation
    
    async def _save_report(self, event_id: str, report: Dict[str, Any]) -> bool:
        """Save report to disk"""
        try:
            timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
            
            # Save JSON report
            json_path = self.reports_dir / f"{event_id}_{timestamp}.json"
            with open(json_path, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            
            # Save Markdown report
            markdown_path = self.reports_dir / f"{event_id}_{timestamp}.md"
            with open(markdown_path, 'w') as f:
                f.write(report['formats']['markdown'])
            
            self.logger.info(f"Saved report files: {json_path}, {markdown_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to save report: {e}")
            return False
    
    def _generate_error_report(self, context, error: Exception) -> Dict[str, Any]:
        """Generate minimal error report when main report generation fails"""
        return {
            'metadata': {
                'event_id': getattr(context, 'event_id', 'unknown'),
                'status': 'ERROR',
                'error': str(error),
                'generated_at': datetime.utcnow().isoformat()
            },
            'executive_summary': f"Report generation failed: {str(error)}",
            'recommended_actions': [{
                'action_type': 'ESCALATE',
                'priority': 1,
                'description': 'Manual investigation required due to reporting system error',
                'estimated_effort': '30 minutes'
            }]
        } 